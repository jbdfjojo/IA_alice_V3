bonjour je souhaiterai que tu m'aide a corriger les erreurs et am√©liorer un projet de IA auto √©volutive en python dans un environnement conda.
je te donne la structure du projet et je souhaite garder les fonctionnalit√© ( g√©n√©ration de code, g√©n√©ration d'image, quel parle, que je puisse √©crire en parlant et la m√©moire qui passe par MySQL).
j'utilise deux model donc je souhaite garder la box pour changer quand je le souhaite.
le chemin de mon projet est : C:\Users\Blazufr\Desktop\IA_alice_V3.
  

asset
images
model
src
main_window.py
memory.db
environment.yml
config.json

model/mistral-7b-instruct-v0.2.Q8_0.gguf
model/nous-hermes-llama2-13b.Q8_0.gguf

src/agent
src/db
src/gui
src/utils
src/app.py
src/llama_cpp_agent.py

src/agent/stable-diffusion-v1-5
src/agent/generate.py
src/agent/voice_thread.py

src/db/memory_viewer.py
src/db/mysql_manager.py

src/gui/main_window.cpp
src/gui/main_window.ui
src/gui/memory_window.py
src/gui/styles.py
src/gui/voice_thread.py

src/utils/database_handler.py
src/utils/logger.py


import os
import json
import time
import psutil 
import pyttsx3
import speech_recognition as sr
import pyperclip
import re
from html import escape
from resource_manager import ResourceManager
from queue import Queue

from PyQt5.QtCore import Qt, QThread, pyqtSignal, QMutex, QThreadPool, QRunnable, QTimer, QMetaObject, Q_ARG, pyqtSlot, QSize
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QTextEdit, QLabel,
    QCheckBox, QComboBox, QMessageBox, QScrollArea, QApplication
)
from PyQt5.QtGui import QPixmap, QTextCursor, QPalette, QColor, QFont, QMovie

from pygments import highlight
from pygments.lexers import get_lexer_by_name
from pygments.formatters import HtmlFormatter

from llama_cpp_agent import LlamaCppAgent

from diffusers import StableDiffusionPipeline

try:
    from PyQt5.QtCore import qRegisterMetaType
    from PyQt5.QtGui import QTextCursor
    qRegisterMetaType(QTextCursor, "QTextCursor")
except Exception as e:
    print(f"Warning qRegisterMetaType QTextCursor skipped: {e}")

# Ajout d'une m√©thode utilitaire pour cr√©er un QLabel styl√©
class StyledLabel(QLabel):
    def __init__(self, html):
        super().__init__(html)
        self.setWordWrap(True)
        self.setStyleSheet("margin-top: 2px; margin-bottom: 2px; line-height: 1.2em; padding: 0;")

class InputTextEdit(QTextEdit):
    def __init__(self, parent=None, submit_callback=None):
        super().__init__(parent)
        self.submit_callback = submit_callback

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return and not event.modifiers() & Qt.ShiftModifier:
            if self.submit_callback:
                self.submit_callback()
            event.accept()  # emp√™che le retour √† la ligne
        else:
            super().keyPressEvent(event)
class VoiceRecognitionThread(QThread):
    result_signal = pyqtSignal(str)

    def __init__(self, agent):
        super().__init__()
        self.agent = agent
        self.running = True
        self.is_paused = False
        self.is_processing_response = False
        self.mutex = QMutex()
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone(device_index=1)
        self.last_active_time = time.time()
        self.max_inactive_duration = 30

    def run(self):
        with self.microphone as source:
            self.recognizer.adjust_for_ambient_noise(source, duration=1)
            while self.running:
                self.mutex.lock()
                paused = self.is_paused
                self.mutex.unlock()

                if paused:
                    time.sleep(0.5)
                    continue

                if time.time() - self.last_active_time > self.max_inactive_duration:
                    self.pause()
                    continue

                try:
                    audio = self.recognizer.listen(source, timeout=10)

                    if self.is_paused:
                        continue

                    text = self.recognizer.recognize_google(audio, language="fr-FR").lower()
                    self.last_active_time = time.time()

                    if "alice" in text:
                        cleaned_text = text.split("alice", 1)[-1].strip()
                        if cleaned_text:
                            self.is_processing_response = True
                            self.result_signal.emit(cleaned_text)
                except:
                    pass
                finally:
                    self.is_processing_response = False

    def pause(self):
        self.is_paused = True

    def resume(self):
        self.is_paused = False
        self.last_active_time = time.time()

    def stop(self):
        self.running = False
        self.quit()
        self.wait()


class RunnableFunc(QRunnable):
    def __init__(self, func):
        super().__init__()
        self.func = func

    def run(self):
        self.func()


def load_config():
    if os.path.exists("config.json"):
        with open("config.json", "r") as file:
            try:
                return json.load(file)
            except json.JSONDecodeError:
                pass
    return {}


def save_config(config):
    with open("config.json", "w") as file:
        json.dump(config, file, indent=4)


class MainWindow(QWidget):
    def __init__(self, model_paths: dict, agent):
        super().__init__()
        self.setWindowTitle("Alice - Interface IA")
        self.setGeometry(100, 100, 800, 600)

        self.model_paths = model_paths
        self.agent = agent
        self.config = load_config()

        self.voice_input_enabled = False
        self.voice_recognition_thread = VoiceRecognitionThread(self.agent)
        self.voice_recognition_thread.result_signal.connect(self.on_text_recognized)
        self.is_user_speaking = True

        self.setup_ui()
        self.apply_dark_theme()

        last_model = self.config.get("last_model", "Mistral-7B-Instruct")
        index = self.model_selector.findText(last_model)
        self.model_selector.setCurrentIndex(index if index != -1 else 0)
        self.voice_checkbox.setChecked(self.config.get("voice_enabled", True))

        self.resource_manager = ResourceManager()
        self.resource_manager.register_callback(self.handle_resource_alert)
        self.resource_manager.start()

        # Gestion des t√¢ches lourdes
        self.task_queue = Queue()
        self.task_running = False

    def apply_dark_theme(self):
        dark_palette = QPalette()
        dark_palette.setColor(QPalette.Window, QColor(30, 30, 30))
        dark_palette.setColor(QPalette.WindowText, Qt.white)
        dark_palette.setColor(QPalette.Base, QColor(25, 25, 25))
        dark_palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ToolTipBase, Qt.white)
        dark_palette.setColor(QPalette.ToolTipText, Qt.white)
        dark_palette.setColor(QPalette.Text, Qt.white)
        dark_palette.setColor(QPalette.Button, QColor(53, 53, 53))
        dark_palette.setColor(QPalette.ButtonText, Qt.white)
        dark_palette.setColor(QPalette.BrightText, Qt.red)
        dark_palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
        dark_palette.setColor(QPalette.HighlightedText, Qt.black)

        self.setPalette(dark_palette)
        QApplication.setPalette(dark_palette)

        self.setStyleSheet("""
            QWidget {
                        background-color: #121212;
                        color: #f0f0f0;
                        font-family: Consolas, monospace;
                        font-size: 14px;
                    }
                    QScrollArea {
                        background-color: #121212;
                    }
                    QTextEdit {
                        background-color: #1e1e1e;
                        color: #f0f0f0;
                        border: 1px solid #333;
                        border-radius: 5px;
                        padding: 6px;
                    }
                    QPushButton {
                        background-color: #2d2d2d;
                        color: white;
                        border: 1px solid #444;
                        padding: 6px;
                        border-radius: 6px;
                    }
                    QPushButton:hover {
                        background-color: #3a3a3a;
                    }
                    QLabel {
                        color: #f0f0f0;
                    }
                    QComboBox {
                        background-color: #1e1e1e;
                        color: #f0f0f0;
                        border: 1px solid #333;
                        padding: 4px;
                    }
                    QCheckBox {
                        color: #f0f0f0;
                    }
                """)

    def setup_ui(self):
        layout = QVBoxLayout()

        # --- Ligne du haut : boutons et s√©lecteurs ---
        top_controls = QHBoxLayout()

        # 1. Choix mod√®le  
        self.model_selector = QComboBox()
        self.model_selector.addItems(self.model_paths.keys())
        self.model_selector.currentTextChanged.connect(self.load_model)
        top_controls.addWidget(self.model_selector)

        # 2. Checkbox voix  
        self.voice_checkbox = QCheckBox("Voix")
        self.voice_checkbox.stateChanged.connect(self.toggle_voice)
        top_controls.addWidget(self.voice_checkbox)

        # 3. Micro On/Off  
        self.voice_button = QPushButton("üé§ Micro: OFF")
        self.voice_button.setCheckable(True)
        self.voice_button.clicked.connect(self.toggle_voice_input)
        self.voice_button.setStyleSheet("background-color: lightcoral; font-weight: bold;")
        top_controls.addWidget(self.voice_button)

        # 4. Choix du langage  
        self.language_selector = QComboBox()
        self.language_selector.addItems(["Python", "JavaScript", "C++", "HTML", "SQL"])
        top_controls.addWidget(self.language_selector)

        # 5. Bouton Images  
        self.image_manager_button = QPushButton("Images")
        self.image_manager_button.clicked.connect(self.open_image_manager)
        top_controls.addWidget(self.image_manager_button)

        # 6. Bouton M√©moire  
        self.memory_button = QPushButton("M√©moire")
        self.memory_button.clicked.connect(self.open_memory_window)
        top_controls.addWidget(self.memory_button)

        # 7. Bouton Sauvegarder  
        self.save_button = QPushButton("Sauvegarder")
        self.save_button.clicked.connect(self.save_prompt)
        top_controls.addWidget(self.save_button)

        layout.addLayout(top_controls)

        # --- Milieu : r√©ponse IA (grand champ avec scroll + police Times New Roman 14px) ---
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_widget = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_widget)
        
        self.scroll_layout.setAlignment(Qt.AlignTop)  # üî• ANCRAGE EN HAUT  
        self.scroll_layout.setSpacing(0)               # Pas d'espace entre les √©l√©ments  
        self.scroll_layout.setContentsMargins(0, 0, 0, 0)  # Pas de marges
        
        self.scroll_area.setWidget(self.scroll_widget)
        self.scroll_area.setFont(QFont("Times New Roman", 14))
        
        layout.addWidget(self.scroll_area)

        # --- Zone d'attente centr√©e avec spinner + texte ---
        self.waiting_container = QWidget()
        self.waiting_container.setVisible(False)
        waiting_layout = QHBoxLayout(self.waiting_container)
        waiting_layout.setAlignment(Qt.AlignCenter)

        # Spinner GIF  
        self.spinner_label = QLabel()
        self.spinner_movie = QMovie("assets/spinner_2.gif")
        self.spinner_movie.setScaledSize(QSize(24, 24))  # üîπ Taille r√©duite du spinner  
        if not self.spinner_movie.isValid():
            print("‚ùå Le fichier spinner_2.gif est introuvable ou invalide.")
        else:
            self.spinner_label.setMovie(self.spinner_movie)
        self.spinner_label.setVisible(True)

        # Texte √† c√¥t√© du spinner  
        self.waiting_label = QLabel("Alice r√©fl√©chit...")
        self.waiting_label.setStyleSheet("font-style: italic; font-size: 14px;")
        self.waiting_label.setAlignment(Qt.AlignLeft)

        # Ajouter les deux c√¥te √† c√¥te  
        waiting_layout.addWidget(self.spinner_label)
        waiting_layout.addWidget(self.waiting_label)

        layout.addWidget(self.waiting_container)

        # --- Bas : champ utilisateur r√©duit + bouton Envoyer ---
        bottom_layout = QHBoxLayout()

        self.input_box = InputTextEdit(submit_callback=self.send_prompt)
        self.input_box.setPlaceholderText("Entrez votre message ici...")
        self.input_box.setFont(QFont("Times New Roman", 14))
        self.input_box.setFixedHeight(self.height() // 6)  # ~1/3 de la zone r√©ponse  
        bottom_layout.addWidget(self.input_box)

        self.send_button = QPushButton("Envoyer")
        self.send_button.clicked.connect(self.send_prompt)
        self.send_button.setFixedHeight(40)
        bottom_layout.addWidget(self.send_button)

        layout.addLayout(bottom_layout)

        # --- Appliquer le layout final ---
        self.setLayout(layout)

    def toggle_voice(self, state):
        self.config["voice_enabled"] = bool(state)
        save_config(self.config)

    def toggle_voice_input(self):
        self.voice_input_enabled = not self.voice_input_enabled
        if self.voice_input_enabled:
            self.voice_button.setText("üé§ Micro: ON")
            self.voice_button.setStyleSheet("background-color: lightgreen; font-weight: bold;")
            if not self.voice_recognition_thread.isRunning():
                self.voice_recognition_thread.start()
            else:
                self.voice_recognition_thread.resume()
        else:
            self.voice_button.setText("üé§ Micro: OFF")
            self.voice_button.setStyleSheet("background-color: lightcoral; font-weight: bold;")
            self.voice_recognition_thread.stop()

    def load_model(self, model_name):
        self.config["last_model"] = model_name
        save_config(self.config)
        try:
            self.agent = LlamaCppAgent(self.model_paths, selected_model=model_name)
            self.voice_recognition_thread.agent = self.agent
        except Exception as e:
            print(f"[ERREUR CHARGEMENT MOD√àLE] : {e}")

    def on_text_recognized(self, text):
        print("[DEBUG] Texte brut reconnu :", text)
        if self.is_user_speaking:
            self.scroll_layout.addWidget(StyledLabel(f"<b style='color: lightblue'>[Vous]</b> {text}"))

            self.input_box.setText(text)
            self.is_user_speaking = False
            self.voice_recognition_thread.pause()
            text_lower = text.lower()

            if any(kw in text_lower for kw in ["image", "dessine", "dessin", "photo", "g√©n√®re une image"]):
                self.generate_image_from_text(text)
            elif any(kw in text_lower for kw in ["code", "fonction", "script", "programme", "algo", "python", "afficher", "fonctionne"]):
                self.generate_code_from_text(text)
            else:
                self.generate_model_response(text)

    def generate_code_from_text(self, text):
        self.set_waiting_message("Alice r√©fl√©chit...")
        self.spinner_label.setVisible(True)
        self.spinner_movie.start()
        self.waiting_label.setVisible(True)
        print("[DEBUG] >>> Appel de generate_code_from_text() avec :", text)

        # Message d'attente
        self.scroll_layout.addWidget(StyledLabel("<b style='color: lightgreen'>[Alice]</b> Je g√©n√®re un code... ‚å®Ô∏è"))
        QApplication.processEvents()

        def run():
            print("[DEBUG] ‚Üí D√©but du thread de g√©n√©ration de code")
            language = self.language_selector.currentText()
            code_response = self.agent.generate_code(text, language=language)
            print("[DEBUG] Code brut retourn√© :", repr(code_response))

            match = re.search(r"```(?:\w+)?\s*(.*?)```", code_response, re.DOTALL)
            extracted_code = match.group(1).strip() if match else code_response.strip()

            try:
                lexer = get_lexer_by_name(language.lower(), stripall=True)
            except Exception:
                lexer = get_lexer_by_name("text", stripall=True)

            formatter = HtmlFormatter(style="monokai", noclasses=True)
            highlighted = highlight(extracted_code, lexer, formatter)

            self.clear_waiting_message()
            self.spinner_movie.stop()
            self.spinner_label.setVisible(False)

            # Mise √† jour de l'interface (Qt thread-safe)
            QMetaObject.invokeMethod(self, "append_code_block", Qt.QueuedConnection,
                                    Q_ARG(str, highlighted),
                                    Q_ARG(str, extracted_code))
        QTimer.singleShot(100, lambda: self.scroll_area.verticalScrollBar().setValue(
            self.scroll_area.verticalScrollBar().maximum()))

        QThreadPool.globalInstance().start(RunnableFunc(run))


    @pyqtSlot(str, str)
    def append_code_block(self, highlighted_code, raw_code):
        title = StyledLabel("<b style='color: lightgreen'>[Alice]</b> Voici le code g√©n√©r√© :")
        self.scroll_layout.addWidget(title)

        container = QWidget()
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(2)
        container.setStyleSheet("background-color: #1e1e1e; border-radius: 4px; padding: 0; margin: 0;")
        
        code_display = QTextEdit()
        code_display.setReadOnly(True)
        code_display.setTextInteractionFlags(Qt.TextSelectableByMouse)
        code_display.setStyleSheet("""
            background-color: #1e1e1e;
            color: white;
            border: none;
            padding: 4px;
            margin: 0;
            font-family: Consolas, monospace;
            font-size: 13px;
            line-height: 1.2em;
        """)
        code_display.setMinimumHeight(50)
        code_display.setMaximumHeight(200)
        code_display.setMaximumWidth(450)
        code_display.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        code_display.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

        # Nettoyage du HTML : suppression des <pre> ext√©rieurs inutiles
        cleaned_html = re.sub(r"</?pre[^>]*>", "", highlighted_code, flags=re.IGNORECASE)
        code_display.setHtml(f"<div style='line-height: 1.2em; font-family: Consolas, monospace;'>{cleaned_html}</div>")

        container_layout.addWidget(code_display)

        copy_btn = QPushButton("üìã Copier le code")
        copy_btn.setFixedWidth(160)
        copy_btn.clicked.connect(lambda: pyperclip.copy(raw_code))
        copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #3a3a3a;
                color: white;
                border-radius: 6px;
                padding: 6px;
            }
            QPushButton:hover {
                background-color: #505050;
            }
        """)

        container_layout.addWidget(copy_btn, alignment=Qt.AlignRight)

        self.scroll_layout.addWidget(container)
        QTimer.singleShot(100, lambda: self.scroll_area.verticalScrollBar().setValue(
            self.scroll_area.verticalScrollBar().maximum()
        ))

        if self.voice_checkbox.isChecked():
            self.agent.speak("Voici le code g√©n√©r√©.")
        self.voice_recognition_thread.resume()


    def generate_image_from_text(self, text):
        self.task_queue.put(lambda: self._start_image_generation(text))
        self._process_queue()

        def can_generate_image():
            mem = psutil.virtual_memory()
            print(f"[DEBUG] RAM utilis√©e : {mem.percent}%")
            return mem.percent < 85

        def afficher_erreur(message):
            self.clear_waiting_message()
            self.spinner_movie.stop()
            self.spinner_label.setVisible(False)
            error_label = QLabel(f"<span style='color:red'><b>[ERREUR]</b> {message}</span>")
            error_label.setWordWrap(True)
            self.scroll_layout.addWidget(error_label)

        self.set_waiting_message("Alice r√©fl√©chit...")
        self.spinner_label.setVisible(True)
        self.spinner_movie.start()
        self.waiting_label.setVisible(True)

        label_wait = QLabel("<b>[Alice]</b> Je vais g√©n√©rer une image... Veuillez patienter ‚è≥")
        self.scroll_layout.addWidget(label_wait)
        QApplication.processEvents()

        def run():
            print("[DEBUG] ‚Üí D√©but de run() image")

            if not can_generate_image():
                afficher_erreur("M√©moire insuffisante pour g√©n√©rer une image. Veuillez fermer des applications ou r√©essayer plus tard.")
                return

            result = self.agent.generate_image(text)
            print("[DEBUG] >>> resultat chemin generation image :", result)
            image_path = result.split("#image")[-1].strip() if result and "#image" in result else None
            print("[DEBUG] >>> resultat chemin image_path :", image_path)

            if not image_path or not os.path.exists(image_path):
                afficher_erreur("L'image n'a pas pu √™tre g√©n√©r√©e. Chemin invalide ou g√©n√©ration √©chou√©e.")
                return

            self.image_path_result = image_path
            self.clear_waiting_message()
            self.spinner_movie.stop()
            self.spinner_label.setVisible(False)
            QTimer.singleShot(0, self.display_generated_image)

        QTimer.singleShot(100, lambda: self.scroll_area.verticalScrollBar().setValue(
            self.scroll_area.verticalScrollBar().maximum()))

        QThreadPool.globalInstance().start(RunnableFunc(run))


    def display_generated_image(self):
        print("[DEBUG] ‚Üí Entr√©e dans display_generated_image()")
        image_path = getattr(self, 'image_path_result', None)
        if image_path and os.path.exists(image_path):
            full_path = os.path.abspath(image_path).replace("\\", "/")
            pixmap = QPixmap(full_path)
            print(f"[DEBUG] Chargement pixmap depuis : {full_path} | Null ? {pixmap.isNull()}")

            if not pixmap.isNull():
                label = QLabel("<b>[Alice]</b> Voici votre image g√©n√©r√©e :")
                label.setWordWrap(True)
                label.setStyleSheet("margin-top: 2px; margin-bottom: 2px; line-height: 1.2em;") 
                self.scroll_layout.addWidget(label)

                img_label = QLabel()
                img_label.setAlignment(Qt.AlignCenter)
                img_label.setPixmap(pixmap.scaledToWidth(350, Qt.SmoothTransformation))
                img_label.setStyleSheet("margin-top: 10px; margin-bottom: 10px;")
                self.scroll_layout.addWidget(img_label)
            else:
                self.scroll_layout.addWidget(QLabel("<b>[Alice]</b> L'image est invalide ou corrompue."))
        else:
            self.scroll_layout.addWidget(QLabel("<b>[Alice]</b> Erreur : image introuvable."))

        self.voice_recognition_thread.resume()

    def generate_model_response(self, prompt):
        self.set_waiting_message("Alice r√©fl√©chit...")
        print("[DEBUG] >>> Appel de generate_model_response() avec :", prompt)

        def run():
            response = self.agent.generate(prompt)
            print("[DEBUG] R√©ponse brute :", response)

            # Passage au thread principal pour mise √† jour UI
            QMetaObject.invokeMethod(
                self,
                "display_model_response",
                Qt.QueuedConnection,
                Q_ARG(str, response)
            )

        QThreadPool.globalInstance().start(RunnableFunc(run))

    @pyqtSlot(str)
    def display_model_response(self, response):
        self.clear_waiting_message()
        self.spinner_movie.stop()
        self.spinner_label.setVisible(False)

        label = StyledLabel(f"<b style='color: lightgreen'>[Alice]</b> <span style='color: white;'>{escape(response)}</span>")
        self.scroll_layout.addWidget(label)
        QTimer.singleShot(100, lambda: self.scroll_area.verticalScrollBar().setValue(
            self.scroll_area.verticalScrollBar().maximum()))

        if self.voice_checkbox.isChecked():
            self.agent.speak(response)

        self.is_user_speaking = True
        self.voice_recognition_thread.resume()



    def send_prompt(self):
        text = self.input_box.toPlainText().strip()
        if not text:
            return

        user_label = StyledLabel(f"<b style='color: lightblue'>[Vous]</b> {escape(text)}")
        self.scroll_layout.addWidget(user_label)
        QTimer.singleShot(100, lambda: self.scroll_area.verticalScrollBar().setValue(
            self.scroll_area.verticalScrollBar().maximum()))

        self.input_box.clear()

        text_lower = text.lower()
        if any(kw in text_lower for kw in ["image", "dessine", "dessin", "photo", "g√©n√®re une image"]):
            self.generate_image_from_text(text)
        elif any(kw in text_lower for kw in ["code", "fonction", "script", "programme", "algo", "python", "afficher", "fonctionne"]):
            self.generate_code_from_text(text)
        else:
            self.generate_model_response(text)


    def save_prompt(self):
        prompt = self.input_box.toPlainText().strip()
        if prompt:
            self.agent.save_to_memory(prompt, "Interaction sauvegard√©e manuellement.")
            self.response_box.append("[‚úî] Interaction sauvegard√©e.")

    def open_memory_window(self):
        from gui.memory_window import MemoryViewer
        self.mem_window = MemoryViewer(self.agent, style_sheet=self.styleSheet())  # <-- garde une r√©f√©rence
        self.mem_window.show()



    def closeEvent(self, event):
        self.voice_recognition_thread.stop()
        event.accept()

    def copy_last_code(self):
        cursor = self.response_box.textCursor()
        cursor.select(QTextCursor.Document)
        pyperclip.copy(cursor.selectedText())
        QMessageBox.information(self, "Copi√©", "Code copi√© dans le presse-papiers.")

    def open_image_manager(self):
        from gui.image_manager import ImageManager
        self.image_window = ImageManager(style_sheet=self.styleSheet())
        self.image_window.show()

    def set_waiting_message(self, message: str):
        self.waiting_label.setText(message)
        self.spinner_movie.start()
        self.waiting_container.setVisible(True)
        QApplication.processEvents()

    def clear_waiting_message(self):
        self.spinner_movie.stop()
        self.waiting_container.setVisible(False)

    def add_code_block(self, highlighted_code: str, raw_code: str):
        container = QWidget()
        container_layout = QVBoxLayout(container)

        code_display = QTextEdit()
        code_display.setReadOnly(True)
        code_display.setTextInteractionFlags(Qt.TextSelectableByMouse)
        code_display.setHtml(f"""
            <div style="font-family: Consolas; font-size: 13px; line-height: 1.2em; margin:0; padding:0;">
                {highlighted_code}
            </div>
        """)

        container_layout.addWidget(code_display)

        copy_btn = QPushButton("üìã Copier le code")
        copy_btn.setFixedWidth(150)
        copy_btn.clicked.connect(lambda: pyperclip.copy(raw_code))
        copy_btn.setStyleSheet("margin-top: 5px; margin-bottom: 10px;")
        container_layout.addWidget(copy_btn, alignment=Qt.AlignCenter)

        self.scroll_layout.addWidget(container)


    def afficher_erreur(self, message):
        self.scroll_layout.addWidget(StyledLabel(
            f"<span style='color:red'><b>[ERREUR]</b> {message}</span>"
        ))

    def handle_resource_alert(self, overloaded, cpu, ram):
        if overloaded:
            alert = f"<b>[Alerte syst√®me]</b> CPU: {cpu:.1f}%, RAM: {ram:.1f}% ‚ûú surcharge d√©tect√©e ‚ö†Ô∏è"
            self.scroll_layout.addWidget(QLabel(alert))
            print("[ALERTE] Ressources critiques d√©tect√©es.")
        else:
            print(f"[INFO] Ressources OK ‚Äî CPU: {cpu:.1f}%, RAM: {ram:.1f}%")

    def _process_queue(self):
        if not self.task_running and not self.task_queue.empty():
            self.task_running = True
            task = self.task_queue.get()
            QTimer.singleShot(0, task)

    def _start_image_generation(self, text):
        def run():
            # m√™me contenu qu‚Äôavant dans run()
            ...
            self.task_running = False
            self._process_queue()  # Reprend les t√¢ches en file
        QThreadPool.globalInstance().start(RunnableFunc(run))



import json
import pyttsx3
import subprocess
from llama_cpp import Llama
from db.mysql_manager import MySQLManager
import threading
from datetime import datetime
from agent import generate 
from agent.generate import generate_image
from diffusers import StableDiffusionPipeline
import torch_directml
import os


class LlamaCppAgent:
    def __init__(self, model_paths: dict, selected_model="Mistral-7B-Instruct"):
        self.model_paths = model_paths
        self.model_path = model_paths.get(selected_model)
        if not self.model_path or not os.path.exists(self.model_path):
            raise FileNotFoundError(f"Mod√®le introuvable : {self.model_path}")
        
        print(f"[INFO] Chargement du mod√®le : {self.model_path}")
        try:
            self.model = Llama(
                model_path=self.model_path,
                n_ctx=1024,
                n_threads=6,
                n_gpu_layers=0,
                seed=42,
                verbose=True
            )
        except Exception as e:
            print(f"[ERREUR] Chargement du mod√®le : {e}")
            self.model = None

        self.engine = pyttsx3.init()
        voices = self.engine.getProperty('voices')
        for voice in voices:
            if "french" in voice.name.lower():
                self.engine.setProperty('voice', voice.id)
                break

        self.speech_enabled = True
        self.db_manager = MySQLManager("localhost", "root", "JOJOJOJO88", "ia_alice")
        self.first_interaction = True

    def set_speech_enabled(self, enabled: bool):
        self.speech_enabled = enabled

    def speak(self, text: str):
        if self.speech_enabled and text.strip():
            try:
                self.engine.say(text)
                self.engine.runAndWait()
            except Exception as e:
                print(f"[ERREUR VOCALE] : {e}")

    def generate(self, prompt: str) -> str:
        if not self.model:
            return "[ERREUR] Mod√®le non initialis√©."
        prompt = prompt.strip()
        if not prompt:
            return "[ERREUR] Prompt vide."

        should_save = "#save" in prompt
        cleaned_prompt = prompt.replace("#save", "").strip()

        final_prompt = (
            "Tu es une IA qui parle exclusivement en fran√ßais.\n"
            "R√©ponds toujours de fa√ßon claire et concise.\n"
            f"Utilisateur : {cleaned_prompt}\nAlice :"
        )

        try:
            result = self.model.create_completion(
                prompt=final_prompt,
                max_tokens=400,
                temperature=0.7,
                top_p=0.9,
                stop=["\nUtilisateur:", "\nAlice:", "\n"]
            )
            if isinstance(result, dict) and "choices" in result and result["choices"]:
                answer = result["choices"][0]["text"].strip()
            else:
                answer = "[ERREUR] R√©ponse invalide."

            if not answer or len(answer.split()) < 2:
                return "[ERREUR] R√©ponse trop courte ou vide."

            if should_save:
                self.save_to_memory(cleaned_prompt, answer)

            return answer
        except Exception as e:
            return f"[ERREUR] Erreur g√©n√©ration : {str(e)}"

    def generate_code(self, user_request: str, language: str = "Python") -> str:
        try:
            prompt = f"""Tu es un assistant expert en programmation. 
            Ne retourne que du code. Ne mets aucune explication. R√©ponds uniquement avec un bloc de code Markdown.

            ### Question
            {user_request.strip()}

            ### R√©ponse
            ```{language.lower()}
            """

            response = self.model.create_completion(
                prompt=prompt,
                max_tokens=400,
                temperature=0.1,
                top_p=1.0,
                stop=["```"]
            )

            if "choices" in response and response["choices"]:
                code = response["choices"][0]["text"].strip()
                if not code:
                    return "[ERREUR] Code vide ou invalide"
                if not code.startswith("```"):
                    code = f"```{language.lower()}\n{code}\n```"

                if "#save" in user_request:
                    self.save_to_memory(user_request.replace("#save", "").strip(), code)

                return code

            return "[ERREUR] R√©ponse invalide"

        except Exception as e:
            return f"[ERREUR] Exception : {e}"

    def generate_image(self, prompt: str) -> str:
        try:
            print("[INFO] Lancement de la g√©n√©ration via subprocess")
            script_path = os.path.abspath("src/agent/generate.py")

            output = subprocess.check_output(
                ["python", script_path, "--prompt", prompt],
                stderr=subprocess.STDOUT,
                text=True,
                timeout=60
            )

            for line in output.splitlines():
                if "#image" in line:
                    return line.strip()

            return "[ERREUR] Aucune image g√©n√©r√©e."

        except subprocess.TimeoutExpired:
            return "[ERREUR] Timeout de g√©n√©ration."
        except subprocess.CalledProcessError as e:
            return f"[ERREUR] G√©n√©ration √©chou√©e : {e.output}"
        except Exception as e:
            return f"[ERREUR] Exception : {str(e)}"

    def save_to_memory(self, prompt: str, response: str):
        try:
            if len(prompt) < 15 or len(response) < 5:
                return  # filtre basique
            self.db_manager.save_memory(prompt, response)
        except Exception as e:
            print(f"[ERREUR M√âMOIRE] : {e}")

    def process_voice_input(self, voice_input: str):
        print(f"[VOICE INPUT] : {voice_input}")
        if not voice_input.strip():
            return "[ERREUR] Aucune entr√©e d√©tect√©e."
        if "timeout" in voice_input.lower() or "audio incompr√©hensible" in voice_input.lower():
            return "[ERREUR] Entr√©e audio invalide."
        return self.generate(voice_input)

